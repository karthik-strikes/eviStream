You are an expert system architect specializing in pipeline orchestration and data flow design.

YOUR TASK: Given the atomic signatures from Stage 1, create the COMBINER signature and PIPELINE FLOW.

═══════════════════════════════════════════════════════════════════════════════
ATOMIC SIGNATURES FROM STAGE 1
═══════════════════════════════════════════════════════════════════════════════

[[ATOMIC_SIGNATURES_JSON]]

═══════════════════════════════════════════════════════════════════════════════
ORIGINAL FORM SPECIFICATION
═══════════════════════════════════════════════════════════════════════════════

[[FORM_DATA_JSON]]

═══════════════════════════════════════════════════════════════════════════════
PIPELINE FLOW DESIGN PRINCIPLES
═══════════════════════════════════════════════════════════════════════════════

1. **IDENTIFY DEPENDENCIES**
   - Does any signature need output from another signature?
   - Check if any signature has `requires_context: true`
   - Check `context_fields` to see what field names they need

2. **ORGANIZE INTO STAGES**
   - Foundation Stage: Signatures that provide context for others (run first)
   - Parallel Stage: Independent signatures with no dependencies (run concurrently)
   - Conditional Stage: Signatures depending on foundation (run after foundation)
   - Combiner Stage: Final merge (always runs last)

3. **EXECUTION STRATEGY**
   - parallel: All signatures in stage run simultaneously
   - sequential: Signatures run one after another

═══════════════════════════════════════════════════════════════════════════════
COMBINER SIGNATURE DESIGN PRINCIPLES
═══════════════════════════════════════════════════════════════════════════════

⚠️  IMPORTANT: Since atomic signatures now produce INDIVIDUAL fields (not composite JSON),
the combiner works differently:

The combiner:
1. **Takes ALL individual field outputs as context** - context_fields MUST include every field name from all atomic signatures' fields_handled arrays
2. **Does NOT perform new extraction** - only validates and structures existing data
3. **Creates final unified output** - organizes all individual fields into final structure
4. **No actual merging needed** - fields are already individual outputs

⚠️  CRITICAL: combiner's context_fields = ALL field names from ALL atomic signatures' fields_handled arrays

Example:
If you have atomic signatures with:
- ExtractTextualDetails: fields_handled = ["drug_name", "duration", "formulation"]
- ClassifyEnumeratedFields: fields_handled = ["intervention_type", "route"]
- ExtractNumericValues: fields_handled = ["sample_size", "age_mean"]

Then combiner MUST have:
context_fields: ["drug_name", "duration", "formulation", "intervention_type", "route", "sample_size", "age_mean"]

The combiner essentially validates that all required fields are present and properly formatted.

═══════════════════════════════════════════════════════════════════════════════
OUTPUT FORMAT (ENFORCED BY PYDANTIC)
═══════════════════════════════════════════════════════════════════════════════

⚠️  CRITICAL: DO NOT generate field_to_signature_map - this is auto-generated by code!

You MUST return a JSON object matching this structure:

{
    "reasoning_trace": "Your reasoning about pipeline flow and combiner design",
    
    "pipeline_flow": {
        "stages": [
            {
                "stage_name": "parallel_extraction",
                "stage_number": 1,
                "signatures": ["ExtractTextualDetails", "ClassifyEnumeratedFields", "ExtractNumericValues"],
                "execution": "parallel",
                "dependencies": [],
                "provides_context": ["drug_name", "duration", "formulation", "intervention_type", "route", "sample_size", "age_mean"],
                "requires_context": [],
                "description": "Independent signatures that extract individual fields in parallel"
            },
            {
                "stage_name": "aggregation",
                "stage_number": 2,
                "signatures": ["AggregateSummary"],
                "execution": "sequential",
                "dependencies": ["parallel_extraction"],
                "provides_context": ["summary"],
                "requires_context": ["drug_name", "duration", "intervention_type", "sample_size"],
                "description": "Aggregation signature that depends on extracted fields"
            }
        ]
    },
    
    "combiner_signature": {
        "signature_name": "CombineAllFields",
        "questionnaire_spec": {
            "class_name": "CombineAllFields",
            "form_question": "Validate and structure all extracted fields",
            "description": "Validate that all required fields are present and properly formatted",
            "output_structure": {
                "drug_name": {"type": "text"},
                "duration": {"type": "text"},
                "formulation": {"type": "text"},
                "intervention_type": {"type": "enum"},
                "route": {"type": "enum"},
                "sample_size": {"type": "number"},
                "age_mean": {"type": "number"},
                "summary": {"type": "text"}
            },
            "output_field_name": "complete_extraction",
            "requires_context": true,
            "context_fields": ["drug_name", "duration", "formulation", "intervention_type", "route", "sample_size", "age_mean", "summary"]
        }
    }
}

═══════════════════════════════════════════════════════════════════════════════
STAGE DESIGN RULES
═══════════════════════════════════════════════════════════════════════════════

**provides_context**: List of FIELD NAMES that this stage's signatures produce
- NOT signature names or composite output names
- Individual field names from fields_handled arrays
- Example: ["drug_name", "duration", "formulation"]

**requires_context**: List of FIELD NAMES that this stage needs as input
- Field names from context_fields of signatures in this stage
- Example: ["drug_name", "intervention_type"]

**dependencies**: List of STAGE NAMES that must complete before this stage
- Stage names, not signature names
- Example: ["parallel_extraction", "foundation_stage"]

═══════════════════════════════════════════════════════════════════════════════
COMBINER REQUIREMENTS
═══════════════════════════════════════════════════════════════════════════════

1. **context_fields**: MUST include ALL individual field names from ALL atomic signatures
   - Collect all fields from fields_handled arrays
   - These become dspy.InputField in the combiner signature

2. **output_structure**: MUST include ALL form fields with their types
   - Copy type information from atomic signatures' output_structure
   - This defines the final output schema

3. **requires_context**: ALWAYS true (combiner always needs input from atomic signatures)

4. **Purpose**: The combiner validates completeness and can perform final formatting
   - It doesn't "merge" JSON objects (since fields are already individual)
   - It ensures all required fields are present
   - It can apply final validation rules

═══════════════════════════════════════════════════════════════════════════════
EXAMPLE: BUILDING COMBINER CONTEXT_FIELDS
═══════════════════════════════════════════════════════════════════════════════

Given atomic signatures:
```json
[
  {
    "signature_name": "ExtractTextualDetails",
    "fields_handled": ["drug_name", "duration", "formulation"]
  },
  {
    "signature_name": "ClassifyEnumeratedFields",
    "fields_handled": ["intervention_type", "route"]
  },
  {
    "signature_name": "ExtractNumericValues",
    "fields_handled": ["sample_size", "age_mean"]
  },
  {
    "signature_name": "AggregateSummary",
    "fields_handled": ["summary"],
    "requires_context": true,
    "context_fields": ["drug_name", "duration", "intervention_type"]
  }
]
```

Combiner context_fields should be:
```json
"context_fields": [
  "drug_name",
  "duration", 
  "formulation",
  "intervention_type",
  "route",
  "sample_size",
  "age_mean",
  "summary"
]
```

This is the UNION of all fields_handled from all atomic signatures.

═══════════════════════════════════════════════════════════════════════════════
CRITICAL REQUIREMENTS ⚠️
═══════════════════════════════════════════════════════════════════════════════

1. ✅ combiner's context_fields MUST include ALL field names from ALL atomic signatures' fields_handled

2. ✅ pipeline_flow.stages MUST NOT be empty - at least 1 stage required

3. ✅ combiner's output_structure MUST include ALL form fields with their types

4. ✅ Stage provides_context lists FIELD NAMES that stage produces (from fields_handled)

5. ✅ Stage requires_context lists FIELD NAMES that stage needs (from context_fields)

6. ✅ If no dependencies exist, use one parallel stage with all atomic signatures

7. ❌ DO NOT generate field_to_signature_map - code will auto-generate this

8. ✅ Combiner validates completeness, not merging (fields are already individual)

═══════════════════════════════════════════════════════════════════════════════
COMMON PATTERNS
═══════════════════════════════════════════════════════════════════════════════

**Pattern 1: All Independent (Most Common)**
```json
{
  "stages": [
    {
      "stage_name": "parallel_extraction",
      "stage_number": 1,
      "signatures": ["ExtractTextualDetails", "ClassifyEnumeratedFields", "ExtractNumericValues"],
      "execution": "parallel",
      "dependencies": [],
      "provides_context": ["drug_name", "duration", "formulation", "intervention_type", "route", "sample_size", "age_mean"],
      "requires_context": []
    }
  ]
}
```

**Pattern 2: Foundation + Dependent**
```json
{
  "stages": [
    {
      "stage_name": "foundation_extraction",
      "stage_number": 1,
      "signatures": ["ExtractTextualDetails", "ExtractNumericValues"],
      "execution": "parallel",
      "dependencies": [],
      "provides_context": ["drug_name", "duration", "sample_size"],
      "requires_context": []
    },
    {
      "stage_name": "dependent_aggregation",
      "stage_number": 2,
      "signatures": ["AggregateSummary"],
      "execution": "sequential",
      "dependencies": ["foundation_extraction"],
      "provides_context": ["summary"],
      "requires_context": ["drug_name", "duration", "sample_size"]
    }
  ]
}
```

**Pattern 3: Sequential Chain**
```json
{
  "stages": [
    {
      "stage_name": "stage_1",
      "signatures": ["ExtractBasicInfo"],
      "provides_context": ["field_a", "field_b"]
    },
    {
      "stage_name": "stage_2",
      "signatures": ["ProcessWithContext"],
      "dependencies": ["stage_1"],
      "requires_context": ["field_a"],
      "provides_context": ["field_c"]
    },
    {
      "stage_name": "stage_3",
      "signatures": ["FinalAggregation"],
      "dependencies": ["stage_2"],
      "requires_context": ["field_b", "field_c"],
      "provides_context": ["final_output"]
    }
  ]
}
```

═══════════════════════════════════════════════════════════════════════════════
NOW CREATE THE COMBINER AND PIPELINE FLOW
═══════════════════════════════════════════════════════════════════════════════

Analyze dependencies by looking at:
1. Which signatures have requires_context: true
2. What field names they need in context_fields
3. Which signatures produce those fields (check fields_handled)

Design the flow:
1. Group independent signatures into parallel stages
2. Create separate stages for signatures with dependencies
3. Ensure stage dependencies match data flow

Build the combiner:
1. Collect ALL field names from ALL atomic signatures' fields_handled
2. Add them all to combiner's context_fields
3. Define output_structure with all fields and their types

Output the JSON (without field_to_signature_map).